DJango - FrameWork Web
	
Vamos usa-lo primeiramente para criar um site que mostra imagens de fotos que a Nasa tirou e ao clicar mostrar um texto sobre ela. Então vamos criar templates html e uso de bancos.
Nestas aulas iniciais não terá foco em API REST, e sim site web. Teremos entao Front e Back End.

Usaremos DJango 4.

Instalações no Windows:

	curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
	python get-pip.py
	pip install virtualenv

Para sistemas Linux:
	
	sudo apt install python3-pip
	pip install virtualenv

Na pasta zipada chamada "alura_space-projeto_front.zip" temos os templates em html e css para o projeto.

Aula 1

	DJango é focado a orientação a conteúdo (content-driven) e nao a orientado a objeto. Foco em dev em site de noticias, blogs e foruns.

	Provem estrutura para uso de banco de dados nativo. Ele tem ferramentas para conexao, e já tem como padrão dentro dele o SQLITE.

	Facilita a construção de CRUD.

	Ferramenta de código aberto (livre e gratuito). Criado em 2005.

	Por que usar DJANGO?
		- Sintaxe simples e objetiva.
		- ORM nativo (Não vai precisar escrever SQL na mão, ele já faz as buscas direto para você).
		- Interface de Administrador.
		- Segurança (Ataques de cross e injection são comunicados a comunidade que ja desenvolve melhorias).
		- Arquitetura MVT (MVC) - é semelhante ao MVC (Model, View e Controller) mas Model (estrutura logica, como os dados vao se comportar no banco de dados), View é similar ao Controller, e o T é o Template, onde ficarão os templates html.
		- Comunidade ativa, muito bem documentado.
		- Estrutura completa. Já temos banco de dados nativo, interação com banco, troca de linguagem (portugues) e etc.
		- Unica fonte de verdade. Se quisermos que o FRONT e o BACK estejam no mesmo lugar, o DJANGO é uma exelente escolha. FULLSTACK.

Aula 2

	Para boas práticas, vamos criar um ambiente virtual para instalar o DJANGO. Isolando os pacotes.

	Usando o comando abaixo na pasta que escolheu para criar a APP.

		virtualenv venv

	No caso ele criou o nome da pasta com o ambiente chamada "venv", mas pode ser qualquer nome, "zope".

	Mas como estou com linux com python2.7, vou enfatizar que quero no python3

		virtualenv --python=python3 venv

	A estrutura que criou:

		venv
		|____ bin (dir)
		|____ lib (dir)
		|____ pyvenv.cfg
		|____ .gitignore

	Quando criamos uma VN, precisamos ativa-la para que continuemos utilizando este projeto, falando que está ativo, posso usar as dependencias carregar o projeto.
	E para isso vamos dentro de bin e com o arquivo activate, pelo terminal, usaremos:

		no windows:

			venv/Script/activate

		no linux:

			source bin/activate

	Assim, o terminal passa a ter venv no começo da linha:

		(venv) henriquef@henrique

	Isso significa que o ambiente virtual está ativado.

	Para desativar:

		deactivate

	Instalando o DJANGO:

		pip install django

	com o venv, nao precisamos dizer qual o diretorio está o pip, ele já sabe que está dentro do venv.

Aula 3

	Visualizando as dependencias do projeto.

		pip freeze

	Mostra os pacotes instalados e necessários para o projeto.

		asgiref==3.8.1
		backports.zoneinfo==0.2.1
		Django==4.2.13
		sqlparse==0.5.0
		typing_extensions==4.11.0

	Uma boa prática é ja criarmos um requirements.txt:

		(venv) henriquef@henriquef-Latitude-3420:~/Documentos/Aulas/Python/DJango$ pip freeze > requirements.txt

	Lembre-se se estar na pasta raiz, pelo menos o professor colocou o requirements fora do venv. Isso porque nao vamos instalar o DJango dentro do venv, e sim numa pasta apartada dentro da raiz, usaremos o venv apenas como ferramentas de codigos. 

		DJango
		|___venv
			|____ bin (dir)
			|____ lib (dir)
			|____ pyvenv.cfg
			|____ .gitignore
		|____ requirements.txt

	Ainda não carregamos o DJango na Aplicação, mas antes
	Comandos do DJango:

		django-admin help

	Mostra inumeros comandos que ele tem.

		django-admin help

		Type 'django-admin help <subcommand>' for help on a specific subcommand.

		Available subcommands:

		[django]
		    check
		    compilemessages
		    createcachetable
		    dbshell
		    diffsettings
		    dumpdata
		    flush
		    inspectdb
		    loaddata
		    makemessages
		    makemigrations
		    migrate
		    optimizemigration
		    runserver
		    sendtestemail
		    shell
		    showmigrations
		    sqlflush
		    sqlmigrate
		    sqlsequencereset
		    squashmigrations
		    startapp
		    startproject
		    test
		    testserver
		Note that only Django core commands are listed as settings are not properly configured (error: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.).

	Para inicializarmos o DJango, vamos usar o startproject, com o nome do projeto. Mas com boas praticas, o ideal é colocar setup ou config, pois vai manter todos os codigos relacionados a configuracao do projeto como um todo. O ponto no final para nao criar subpasta no arquivo de configuracao, caso contrario criaria setup/setup

		django-admin startproject setup .

		(venv) henriquef@henriquef-Latitude-3420:~/Documentos/Aulas/Python/DJango$ django-admin startproject setup .

	Criou:

		DJango
		|___venv
			|____ bin (dir)
			|____ lib (dir)
			|____ pyvenv.cfg
			|____ .gitignore
		|____ setup
			|____ __init__.py
			|____ aspi.py
			|____ settings.py
			|____ urls.py
			|____ wsgi.py
		|____ manage.py
		|____ requirements.txt

	Perceba que ele nao criou dentro de venv, criou fora, usando o ambiente virtual simplesmente como ferramenta ativa! Muito Legal! Meu Zope sempre coloquei dentro e nao precisava!

	O start project criou tambem um manage.py na raiz.
	responsavel por realizar por rodar comandos no django, como subir o servidor.

	Para subir o servidor, inicia-lo.

		python manage.py runserver

	Assim, com a URL, conseguimos ver a pagina de instalação do django:

		http://127.0.0.1:8000/

	O legal do runserver é que quando eu for mexendo no codigo ele já vai reiniciando automatico!

	Ele deu um warning:

		You have 18 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.
		Run 'python manage.py migrate' to apply them.

	Isso é apenas para falar que pode upar a estrutura, como do sql, no server, mas veremos isso depois.


Observações:

	Tipos de ambientes virtuais:

		venv: É o ambiente virtual “padrão” do Python e sua grande vantagem é já vir instalado como um módulo na linguagem a partir da versão 3.3. Se trata de um subset (parte menor) da ferramenta virtualenv.

		Virtualenv: É uma ferramenta feita especificamente para a criação de ambientes virtuais e precede a criação da venv, sendo um superset (parte maior) dela. Algumas de sua principais vantagens sobre a venv são:
		Maior velocidade, graças ao método app-data seed;
		Pode criar ambientes virtuais para versões arbitrárias do Python instaladas na máquina;
		Pode ser atualizado utilizando a ferramenta pip;
		Possui uma Programmatic API, capaz de descrever um ambiente virtual sem criá-lo.

		Conda: É uma alternativa não apenas às ferramentas de ambiente virtuais já citadas, mas ao instalador de pacotes pip também. Possui um escopo mais centrado na área de ciência de dados e possui a capacidade de instalar pacotes fora do ecossistema do Python.

		Virtualenvwrapper: É uma extensão do projeto Virtualenv que torna a criação, deleção e gerenciamento geral dos ambientes virtuais mais fácil. Uma grande vantagem de sua utilização é a organização de todos os ambientes virtuais utilizados em um só lugar, além de facilitar os comandos de CLI.

		Poetry: É uma ferramenta para gerenciamento de dependências e pacotes do Python. Através do Poetry é possível declarar quais pacotes um projeto necessita para funcionar, de forma parecida ao requirements.txt, porém, de forma determinística.


Aula 4

	Idioma e Timezone

		As informações onde ficam armazenadas a linguagem e o timezone fica em:

			setup/settings.py

		Neste arquivos temos tudo quanto é tipo de configuração e usaremos bastante!

		E detro do arquivo alteramos estas linhas:

			LANGUAGE_CODE = 'en-us'

			TIME_ZONE = 'UTC'

		Para:

			LANGUAGE_CODE = 'pt-br'

			TIME_ZONE = 'America/Sao_Paulo'

		O que é muito legal que após salver, ele já renicia o servidor com as infos novas.

		A linguagem alterada consegue ver no http://127.0.0.1:8000/
		E o tempo no proprio terminal:

			[16/May/2024 16:05:40] "GET / HTTP/1.1" 200 10695

		Onde o GET foi a requisição que fizemos para acessar a url acima!


Aula 5
	
	Versionar com o Git/GitHub

	Não vamos querer enviar todo o código para o GitHub, como o venv, manage.py, db.sqlite3.

	Se subirmos o settings.py, o Proprio github manda mensagem de PERIGO pois está enviando a secret ket do DJANGO.

	Todo Projeto DJango tem uma secret key. Se apagarmos a secret, o django da erro, informando que deve entrar em contato com o adm.

	Vamos criar variaveis de ambiente, para manipular o settings sem ele subir com a secret. para isso vamos instalar um pacote.

	Paramos o servidor com ctrl + C.
	E instalamos:

		pip install python-dotenv

	E instalando sempre temos que atualizar o requerements:

		pip freeze > requirements.txt

	fora de /setup, vamos criar um arquivo chamado .env, onde terão nossas variaveis de ambiente.


	DJango
		|___venv
			|____ bin (dir)
			|____ lib (dir)
			|____ pyvenv.cfg
			|____ .gitignore
		|____ setup
			|____ __init__.py
			|____ aspi.py
			|____ settings.py
			|____ urls.py
			|____ wsgi.py
		|____.env
		|____ manage.py
		|____ requirements.txt

	Vamos copiar o conteúdo do SECRET_KEY e colocar no .env.

		SECRET_KEY = django-insecure--0d^8f#m@pcwznllb3ja@esx6v!$5&x8o7$a526!+lw-moxj9-

	***Remova as aspas da STRING!

	E no settings.py

		# no comeco add o "os"
		from pathlib import Path, os
		from dotenv import load_dotenv

		load_dotenv()

		# na variavel SECRET
		SECRET_KEY = str(os.getenv('SECRET_KET'))

	importamos o pacote dotenv e a funcao load_dotenv para carregar as variaveis de ambiente.
	Nao se esqueca de add o "os" dp pathlib, para conseguirmos manipular nossos arquivos.

	load_dotenv() > para carregar as variavei de ambiente quando o settings for chamado.

	os.getenv para buscar a variavel 'SECRET_KEY', e o str porque vem de env sem ser STRING.


Aula 6 - Criando Repositorio no GitHub

	Vou no meu perfil do GitHub > novo repositorio > alura_space

	No projeto, criaremos um .gitignore para que o git ignore o arquivo .env.

		DJango
			|___venv
				|____ bin (dir)
				|____ lib (dir)
				|____ pyvenv.cfg
				|____ .gitignore
			|____ setup
				|____ __init__.py
				|____ aspi.py
				|____ settings.py
				|____ urls.py
				|____ wsgi.py
			|____.env
			|____.gitignore
			|____ manage.py
			|____ requirements.txt

	Na internet ja existem .gitignore prontos so para copiar e colocar.
	no site gitignore.io > coloque no pesquisar o "django". O que ele gerou, copiamos e colamos no nosso:

			# Created by https://www.toptal.com/developers/gitignore/api/django
			# Edit at https://www.toptal.com/developers/gitignore?templates=django

			### Django ###
			*.log
			*.pot
			*.pyc
			__pycache__/
			local_settings.py
			db.sqlite3
			db.sqlite3-journal
			media

			# If your build process includes running collectstatic, then you probably don't need or want to include staticfiles/
			# in your Git repository. Update and uncomment the following line accordingly.
			# <django-project-name>/staticfiles/

			### Django.Python Stack ###
			# Byte-compiled / optimized / DLL files
			*.py[cod]
			*$py.class

			# C extensions
			*.so

			# Distribution / packaging
			.Python
			build/
			develop-eggs/
			dist/
			downloads/
			eggs/
			.eggs/
			lib/
			lib64/
			parts/
			sdist/
			var/
			wheels/
			share/python-wheels/
			*.egg-info/
			.installed.cfg
			*.egg
			MANIFEST

			# PyInstaller
			#  Usually these files are written by a python script from a template
			#  before PyInstaller builds the exe, so as to inject date/other infos into it.
			*.manifest
			*.spec

			# Installer logs
			pip-log.txt
			pip-delete-this-directory.txt

			# Unit test / coverage reports
			htmlcov/
			.tox/
			.nox/
			.coverage
			.coverage.*
			.cache
			nosetests.xml
			coverage.xml
			*.cover
			*.py,cover
			.hypothesis/
			.pytest_cache/
			cover/

			# Translations
			*.mo

			# Django stuff:

			# Flask stuff:
			instance/
			.webassets-cache

			# Scrapy stuff:
			.scrapy

			# Sphinx documentation
			docs/_build/

			# PyBuilder
			.pybuilder/
			target/

			# Jupyter Notebook
			.ipynb_checkpoints

			# IPython
			profile_default/
			ipython_config.py

			# pyenv
			#   For a library or package, you might want to ignore these files since the code is
			#   intended to run in multiple environments; otherwise, check them in:
			# .python-version

			# pipenv
			#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
			#   However, in case of collaboration, if having platform-specific dependencies or dependencies
			#   having no cross-platform support, pipenv may install dependencies that don't work, or not
			#   install all needed dependencies.
			#Pipfile.lock

			# poetry
			#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
			#   This is especially recommended for binary packages to ensure reproducibility, and is more
			#   commonly ignored for libraries.
			#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
			#poetry.lock

			# pdm
			#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
			#pdm.lock
			#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
			#   in version control.
			#   https://pdm.fming.dev/#use-with-ide
			.pdm.toml

			# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
			__pypackages__/

			# Celery stuff
			celerybeat-schedule
			celerybeat.pid

			# SageMath parsed files
			*.sage.py

			# Environments
			.env
			.venv
			env/
			venv/
			ENV/
			env.bak/
			venv.bak/

			# Spyder project settings
			.spyderproject
			.spyproject

			# Rope project settings
			.ropeproject

			# mkdocs documentation
			/site

			# mypy
			.mypy_cache/
			.dmypy.json
			dmypy.json

			# Pyre type checker
			.pyre/

			# pytype static type analyzer
			.pytype/

			# Cython debug symbols
			cython_debug/

			# PyCharm
			#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
			#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
			#  and can be added to the global gitignore or merged into this file.  For a more nuclear
			#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
			#.idea/

			# End of https://www.toptal.com/developers/gitignore/api/django



	Com isso, nao mandamos logs, banco sqlite, media, .pyc e diversos. e la tem o .env . nada do ambiente virtual venv/

















