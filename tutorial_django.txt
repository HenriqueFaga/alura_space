DJango - FrameWork Web
	
Vamos usa-lo primeiramente para criar um site que mostra imagens de fotos que a Nasa tirou e ao clicar mostrar um texto sobre ela. Então vamos criar templates html e uso de bancos.
Nestas aulas iniciais não terá foco em API REST, e sim site web. Teremos entao Front e Back End.

Usaremos DJango 4.

Instalações no Windows:

	curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
	python get-pip.py
	pip install virtualenv

Para sistemas Linux:
	
	sudo apt install python3-pip
	pip install virtualenv

Na pasta zipada chamada "alura_space-projeto_front.zip" temos os templates em html e css para o projeto.

Aula 1

	DJango é focado a orientação a conteúdo (content-driven) e nao a orientado a objeto. Foco em dev em site de noticias, blogs e foruns.

	Provem estrutura para uso de banco de dados nativo. Ele tem ferramentas para conexao, e já tem como padrão dentro dele o SQLITE.

	Facilita a construção de CRUD.

	Ferramenta de código aberto (livre e gratuito). Criado em 2005.

	Por que usar DJANGO?
		- Sintaxe simples e objetiva.
		- ORM nativo (Não vai precisar escrever SQL na mão, ele já faz as buscas direto para você).
		- Interface de Administrador.
		- Segurança (Ataques de cross e injection são comunicados a comunidade que ja desenvolve melhorias).
		- Arquitetura MVT (MVC) - é semelhante ao MVC (Model, View e Controller) mas Model (estrutura logica, como os dados vao se comportar no banco de dados), View é similar ao Controller, e o T é o Template, onde ficarão os templates html.
		- Comunidade ativa, muito bem documentado.
		- Estrutura completa. Já temos banco de dados nativo, interação com banco, troca de linguagem (portugues) e etc.
		- Unica fonte de verdade. Se quisermos que o FRONT e o BACK estejam no mesmo lugar, o DJANGO é uma exelente escolha. FULLSTACK.

Aula 2

	Para boas práticas, vamos criar um ambiente virtual para instalar o DJANGO. Isolando os pacotes.

	Usando o comando abaixo na pasta que escolheu para criar a APP.

		virtualenv venv

	No caso ele criou o nome da pasta com o ambiente chamada "venv", mas pode ser qualquer nome, "zope".

	Mas como estou com linux com python2.7, vou enfatizar que quero no python3

		virtualenv --python=python3 venv

	A estrutura que criou:

		venv
		|____ bin (dir)
		|____ lib (dir)
		|____ pyvenv.cfg
		|____ .gitignore

	Quando criamos uma VN, precisamos ativa-la para que continuemos utilizando este projeto, falando que está ativo, posso usar as dependencias carregar o projeto.
	E para isso vamos dentro de bin e com o arquivo activate, pelo terminal, usaremos:

		no windows:

			venv/Script/activate

		no linux:

			source bin/activate

	Assim, o terminal passa a ter venv no começo da linha:

		(venv) henriquef@henrique

	Isso significa que o ambiente virtual está ativado.

	Para desativar:

		deactivate

	Instalando o DJANGO:

		pip install django

	com o venv, nao precisamos dizer qual o diretorio está o pip, ele já sabe que está dentro do venv.

Aula 3

	Visualizando as dependencias do projeto.

		pip freeze

	Mostra os pacotes instalados e necessários para o projeto.

		asgiref==3.8.1
		backports.zoneinfo==0.2.1
		Django==4.2.13
		sqlparse==0.5.0
		typing_extensions==4.11.0

	Uma boa prática é ja criarmos um requirements.txt:

		(venv) henriquef@henriquef-Latitude-3420:~/Documentos/Aulas/Python/DJango$ pip freeze > requirements.txt

	Lembre-se se estar na pasta raiz, pelo menos o professor colocou o requirements fora do venv. Isso porque nao vamos instalar o DJango dentro do venv, e sim numa pasta apartada dentro da raiz, usaremos o venv apenas como ferramentas de codigos. 

		DJango
		|___venv
			|____ bin (dir)
			|____ lib (dir)
			|____ pyvenv.cfg
			|____ .gitignore
		|____ requirements.txt

	Ainda não carregamos o DJango na Aplicação, mas antes
	Comandos do DJango:

		django-admin help

	Mostra inumeros comandos que ele tem.

		django-admin help

		Type 'django-admin help <subcommand>' for help on a specific subcommand.

		Available subcommands:

		[django]
		    check
		    compilemessages
		    createcachetable
		    dbshell
		    diffsettings
		    dumpdata
		    flush
		    inspectdb
		    loaddata
		    makemessages
		    makemigrations
		    migrate
		    optimizemigration
		    runserver
		    sendtestemail
		    shell
		    showmigrations
		    sqlflush
		    sqlmigrate
		    sqlsequencereset
		    squashmigrations
		    startapp
		    startproject
		    test
		    testserver
		Note that only Django core commands are listed as settings are not properly configured (error: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.).

	Para inicializarmos o DJango, vamos usar o startproject, com o nome do projeto. Mas com boas praticas, o ideal é colocar setup ou config, pois vai manter todos os codigos relacionados a configuracao do projeto como um todo. O ponto no final para nao criar subpasta no arquivo de configuracao, caso contrario criaria setup/setup

		django-admin startproject setup .

		(venv) henriquef@henriquef-Latitude-3420:~/Documentos/Aulas/Python/DJango$ django-admin startproject setup .

	Criou:

		DJango
		|___venv
			|____ bin (dir)
			|____ lib (dir)
			|____ pyvenv.cfg
			|____ .gitignore
		|____ setup
			|____ __init__.py
			|____ aspi.py
			|____ settings.py
			|____ urls.py
			|____ wsgi.py
		|____ manage.py
		|____ requirements.txt

	Perceba que ele nao criou dentro de venv, criou fora, usando o ambiente virtual simplesmente como ferramenta ativa! Muito Legal! Meu Zope sempre coloquei dentro e nao precisava!

	O start project criou tambem um manage.py na raiz.
	responsavel por realizar por rodar comandos no django, como subir o servidor.

	Para subir o servidor, inicia-lo.

		python manage.py runserver

	Assim, com a URL, conseguimos ver a pagina de instalação do django:

		http://127.0.0.1:8000/

	O legal do runserver é que quando eu for mexendo no codigo ele já vai reiniciando automatico!

	Ele deu um warning:

		You have 18 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.
		Run 'python manage.py migrate' to apply them.

	Isso é apenas para falar que pode upar a estrutura, como do sql, no server, mas veremos isso depois.


Observações:

	Tipos de ambientes virtuais:

		venv: É o ambiente virtual “padrão” do Python e sua grande vantagem é já vir instalado como um módulo na linguagem a partir da versão 3.3. Se trata de um subset (parte menor) da ferramenta virtualenv.

		Virtualenv: É uma ferramenta feita especificamente para a criação de ambientes virtuais e precede a criação da venv, sendo um superset (parte maior) dela. Algumas de sua principais vantagens sobre a venv são:
		Maior velocidade, graças ao método app-data seed;
		Pode criar ambientes virtuais para versões arbitrárias do Python instaladas na máquina;
		Pode ser atualizado utilizando a ferramenta pip;
		Possui uma Programmatic API, capaz de descrever um ambiente virtual sem criá-lo.

		Conda: É uma alternativa não apenas às ferramentas de ambiente virtuais já citadas, mas ao instalador de pacotes pip também. Possui um escopo mais centrado na área de ciência de dados e possui a capacidade de instalar pacotes fora do ecossistema do Python.

		Virtualenvwrapper: É uma extensão do projeto Virtualenv que torna a criação, deleção e gerenciamento geral dos ambientes virtuais mais fácil. Uma grande vantagem de sua utilização é a organização de todos os ambientes virtuais utilizados em um só lugar, além de facilitar os comandos de CLI.

		Poetry: É uma ferramenta para gerenciamento de dependências e pacotes do Python. Através do Poetry é possível declarar quais pacotes um projeto necessita para funcionar, de forma parecida ao requirements.txt, porém, de forma determinística.


Aula 4

	Idioma e Timezone

		As informações onde ficam armazenadas a linguagem e o timezone fica em:

			setup/settings.py

		Neste arquivos temos tudo quanto é tipo de configuração e usaremos bastante!

		E detro do arquivo alteramos estas linhas:

			LANGUAGE_CODE = 'en-us'

			TIME_ZONE = 'UTC'

		Para:

			LANGUAGE_CODE = 'pt-br'

			TIME_ZONE = 'America/Sao_Paulo'

		O que é muito legal que após salver, ele já renicia o servidor com as infos novas.

		A linguagem alterada consegue ver no http://127.0.0.1:8000/
		E o tempo no proprio terminal:

			[16/May/2024 16:05:40] "GET / HTTP/1.1" 200 10695

		Onde o GET foi a requisição que fizemos para acessar a url acima!


Aula 5
	
	Versionar com o Git/GitHub

	Não vamos querer enviar todo o código para o GitHub, como o venv, manage.py, db.sqlite3.

	Se subirmos o settings.py, o Proprio github manda mensagem de PERIGO pois está enviando a secret ket do DJANGO.

	Todo Projeto DJango tem uma secret key. Se apagarmos a secret, o django da erro, informando que deve entrar em contato com o adm.

	Vamos criar variaveis de ambiente, para manipular o settings sem ele subir com a secret. para isso vamos instalar um pacote.

	Paramos o servidor com ctrl + C.
	E instalamos:

		pip install python-dotenv

	E instalando sempre temos que atualizar o requerements:

		pip freeze > requirements.txt

	fora de /setup, vamos criar um arquivo chamado .env, onde terão nossas variaveis de ambiente.


	DJango
		|___venv
			|____ bin (dir)
			|____ lib (dir)
			|____ pyvenv.cfg
			|____ .gitignore
		|____ setup
			|____ __init__.py
			|____ aspi.py
			|____ settings.py
			|____ urls.py
			|____ wsgi.py
		|____.env
		|____ manage.py
		|____ requirements.txt

	Vamos copiar o conteúdo do SECRET_KEY e colocar no .env.

		SECRET_KEY = django-insecure--0d^8f#m@pcwznllb3ja@esx6v!$5&x8o7$a526!+lw-moxj9-

	***Remova as aspas da STRING!

	E no settings.py

		# no comeco add o "os"
		from pathlib import Path, os
		from dotenv import load_dotenv

		load_dotenv()

		# na variavel SECRET
		SECRET_KEY = str(os.getenv('SECRET_KET'))

	importamos o pacote dotenv e a funcao load_dotenv para carregar as variaveis de ambiente.
	Nao se esqueca de add o "os" dp pathlib, para conseguirmos manipular nossos arquivos.

	load_dotenv() > para carregar as variavei de ambiente quando o settings for chamado.

	os.getenv para buscar a variavel 'SECRET_KEY', e o str porque vem de env sem ser STRING.


Aula 6 - Criando Repositorio no GitHub

	Vou no meu perfil do GitHub > novo repositorio > alura_space

	No projeto, criaremos um .gitignore para que o git ignore o arquivo .env.

		DJango
			|___venv
				|____ bin (dir)
				|____ lib (dir)
				|____ pyvenv.cfg
				|____ .gitignore
			|____ setup
				|____ __init__.py
				|____ aspi.py
				|____ settings.py
				|____ urls.py
				|____ wsgi.py
			|____.env
			|____.gitignore
			|____ manage.py
			|____ requirements.txt

	Na internet ja existem .gitignore prontos so para copiar e colocar.
	no site gitignore.io > coloque no pesquisar o "django". O que ele gerou, copiamos e colamos no nosso:

			# Created by https://www.toptal.com/developers/gitignore/api/django
			# Edit at https://www.toptal.com/developers/gitignore?templates=django

			### Django ###
			*.log
			*.pot
			*.pyc
			__pycache__/
			local_settings.py
			db.sqlite3
			db.sqlite3-journal
			media

			# If your build process includes running collectstatic, then you probably don't need or want to include staticfiles/
			# in your Git repository. Update and uncomment the following line accordingly.
			# <django-project-name>/staticfiles/

			### Django.Python Stack ###
			# Byte-compiled / optimized / DLL files
			*.py[cod]
			*$py.class

			# C extensions
			*.so

			# Distribution / packaging
			.Python
			build/
			develop-eggs/
			dist/
			downloads/
			eggs/
			.eggs/
			lib/
			lib64/
			parts/
			sdist/
			var/
			wheels/
			share/python-wheels/
			*.egg-info/
			.installed.cfg
			*.egg
			MANIFEST

			# PyInstaller
			#  Usually these files are written by a python script from a template
			#  before PyInstaller builds the exe, so as to inject date/other infos into it.
			*.manifest
			*.spec

			# Installer logs
			pip-log.txt
			pip-delete-this-directory.txt

			# Unit test / coverage reports
			htmlcov/
			.tox/
			.nox/
			.coverage
			.coverage.*
			.cache
			nosetests.xml
			coverage.xml
			*.cover
			*.py,cover
			.hypothesis/
			.pytest_cache/
			cover/

			# Translations
			*.mo

			# Django stuff:

			# Flask stuff:
			instance/
			.webassets-cache

			# Scrapy stuff:
			.scrapy

			# Sphinx documentation
			docs/_build/

			# PyBuilder
			.pybuilder/
			target/

			# Jupyter Notebook
			.ipynb_checkpoints

			# IPython
			profile_default/
			ipython_config.py

			# pyenv
			#   For a library or package, you might want to ignore these files since the code is
			#   intended to run in multiple environments; otherwise, check them in:
			# .python-version

			# pipenv
			#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
			#   However, in case of collaboration, if having platform-specific dependencies or dependencies
			#   having no cross-platform support, pipenv may install dependencies that don't work, or not
			#   install all needed dependencies.
			#Pipfile.lock

			# poetry
			#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
			#   This is especially recommended for binary packages to ensure reproducibility, and is more
			#   commonly ignored for libraries.
			#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
			#poetry.lock

			# pdm
			#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
			#pdm.lock
			#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
			#   in version control.
			#   https://pdm.fming.dev/#use-with-ide
			.pdm.toml

			# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
			__pypackages__/

			# Celery stuff
			celerybeat-schedule
			celerybeat.pid

			# SageMath parsed files
			*.sage.py

			# Environments
			.env
			.venv
			env/
			venv/
			ENV/
			env.bak/
			venv.bak/

			# Spyder project settings
			.spyderproject
			.spyproject

			# Rope project settings
			.ropeproject

			# mkdocs documentation
			/site

			# mypy
			.mypy_cache/
			.dmypy.json
			dmypy.json

			# Pyre type checker
			.pyre/

			# pytype static type analyzer
			.pytype/

			# Cython debug symbols
			cython_debug/

			# PyCharm
			#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
			#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
			#  and can be added to the global gitignore or merged into this file.  For a more nuclear
			#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
			#.idea/

			# End of https://www.toptal.com/developers/gitignore/api/django



	Com isso, nao mandamos logs, banco sqlite, media, .pyc e diversos. e la tem o .env . nada do ambiente virtual venv/

	Bom, agora vamos iniciar um git no repositorio local, para isso ctrl+C na aplicacao. Comando:

		git init

	Ele cria um diretorio .git com todas as ferramentas do git.

	Para add all

		git add .

	Commit:

		git commit -m 'projeto alura space'

	Vamos no GitHub e pegamos a linha:

		git remote add origin https://github.com/HenriqueFaga/alura_space.git


	Para que o repositorio local aponte para o repositorio do GitHub.
	E o comando abaixo para subir o commit por push:

		git push origin master

	master pois nao criamos uma branch, demos commit na master.


Observações:

	Geralmente temos um número vasto de aplicações e programas instalados na nossa máquina física. Muitas dessas ferramentas se conectam na internet e realizam comunicações com servidores distantes, trocando informações constantemente.

	A partir do avanço dos computadores e da internet, houve a necessidade de organizar melhor o meio pelo qual determinadas aplicações contidas em cada máquina se comunicam.

	Para essa tarefa, foi criado o Transmission Control Protocol (TCP) - Protocolo de Controle de Transmissão. Esse protocolo utiliza de artifícios chamados de Portas de Comunicação para gerenciar as trocas de informações de várias aplicações do sistema instaladas na mesma máquina física.

	Aqui estão algumas das Portas de Comunicação mais conhecidas e suas atribuições:

	Porta	Atribuição
	80	HTTP
	433	HTTPS
	22	SSH
	53	DNS
	25	SMTP
	465	SMTPS
	20, 21	FTP
	67, 68	DHCP

Aula 7

	App e Projeto

		Para rodar uma pequena aplicação dentro do django:
			django-admin startapp

		Para começar todo o projeto em django, com todas as configurações:
			django-admin startproject

		Então um project pode conter diversos apps!

		Vamos criar agora um App de galeria, todos os codigos relacionados as imagens que temos!

		Para criar o app de galeria:

			python manage.py startapp galeria

		com isso, ele criou um diretorio galeria na raiz (DJango) com varios codigos:

				DJango
				|___venv
					|____ bin (dir)
					|____ lib (dir)
					|____ pyvenv.cfg
					|____ .gitignore
				|____ setup
					|____ __init__.py
					|____ aspi.py
					|____ settings.py
					|____ urls.py
					|____ wsgi.py
				|____galeria
					|____ migrations
						|____ __init__.py
					|____ __init__.py
					|____ admin.py
					|____ apps.py
					|____ models.py
					|____ tests.py
					|____ views.py
				|____.env
				|____ manage.py
				|____ requirements.txt

		Vamos falar para o projeto que o app galeria faz parte dele. Para isso vamos em:

				setup > settings.py

			Dentro dele, escrever dentro da lista INSTALLED_APPS,
			o nome da aplicação!

				INSTALLED_APPS = [
				    'django.contrib.admin',
				    'django.contrib.auth',
				    'django.contrib.contenttypes',
				    'django.contrib.sessions',
				    'django.contrib.messages',
				    'django.contrib.staticfiles',
				    'galeria',
				]		


Aula 8

	Views e URLS

		o arquivo galeria/views.py tem a responsabilidade principal de cuidar do que vai ser exibido na tela, em cada pagina, o que renderiza.

		Abrindo o codigo, vamos importar o django.http para responder uma requisicao.

			from django.http import HttpResponse

		Ou seja, vem a resquisicao e eu quero responder ela.

		Vamos criar uma função index, ou seja, a pagina principal. E para responder a requisição vamos passar como argumento 'request'. Restornamos um HTML na resposta!

			def index(request):
				return HttpResponse('<h1>Alura Space</h1>')

		Codigo total em galeria/views.py:

			from django.shortcuts import render
			from django.http import HttpResponse

			def index(request):
			    return HttpResponse('<h1>Alura Space</h1>')

		Mas dentro do site ainda nao aparece, e para isso precisamos identificar a ROTA dentro da aplicação!

		em setup > urls.py

		Podemos apagar aqueles comentarios todos.

		importamos index de galeria.views

			from galeria.views import index

		dentro de urlpatterns, criamos um novo path, na raiz, ou seja no '/', vamos mostrar o index. O barra nao informamos, apenas a string vazia.

			path('', index)

		Codigo todo de setup/urls.py:

			from django.contrib import admin
			from django.urls import path
			from galeria.views import index

			urlpatterns = [
			    path('admin/', admin.site.urls),
			    path('', index),
			]

		agora na url 127.0.0.1:8000 mostra:

			Alura Space

Aula 9:

	Isolando as URLS

		Imagine se tiversemos que toda vez colocar dentro de urlpatters cada path de cada App que criarmos, a urls.py ia ficar gigante, cheia de linhas:


			urlpatterns = [
			    path('admin/', admin.site.urls),
			    path('', index),
			    path('', index),
			    path('', index),
			    path('', index),
			    path('', index),
			    path('', index),
			    path('', index),
			    path('', index),
			]

		Vamos fazer com que os proprios apps tenham suas listas de rotas. Vamos isolar este roteamento dentro de galeria.

		vamos criar dentro de galeria um urls.py

		dentro dele importamos render da urls.py e o index

			from django.urls import path
			from galeria.views import index

		Sacada de boa programação:
		Criar uma lista com todos os endpoints (urls) da galeria.

			urlpatterns = [
				path('', index)
			]

		Conteudo total de urls.py de galeria:

            from django.urls import path
            from galeria.views import index

            urlpatterns = [
                path('', index)
            ]

        removemos o import da view em urls.py do setup e importamos de django.urls o include:

            from django.urls import path, include

        e no path, passamos o nome do app com o script urls.py

            urlpatterns = [
                path('admin/', admin.site.urls),
                path('', include('galeria.urls')),
            ]

        Conteudo total de setup/urls.py

            from django.contrib import admin
            from django.urls import path, include


            urlpatterns = [
                path('admin/', admin.site.urls),
                path('', include('galeria.urls')),
            ]

        Assim, realizando o mesmo resultado que da aula 8.

        E se quisermos criar mais paginas em galeria, é so add o path no seu urls e importar a função.

Aula 10:

    Templates

        Não queremos desenvolver todo HTML dentro de HttpResponse, precisamos criar arquivos separados.

        Primeiro, vamos precisar falar para o nosso projeto onde ficam as paginas HTML dele.

        Em setup/settings.py tem uma variavel chamada TEMPLATES, onde ficam toda parte visual da nossa aplicacao. Na key DIRS, fica referente ao local, onde ficam os HTMLS.

        Na raiz do projeto, criaremos uma pasta chamada templates.

                DJango
                |___templates
                |___venv
                    |____ bin (dir)
                    |____ lib (dir)
                    |____ pyvenv.cfg
                    |____ .gitignore
                |____ setup
                    |____ __init__.py
                    |____ aspi.py
                    |____ settings.py
                    |____ urls.py
                    |____ wsgi.py
                |____galeria
                    |____ migrations
                        |____ __init__.py
                    |____ __init__.py
                    |____ admin.py
                    |____ apps.py
                    |____ models.py
                    |____ tests.py
                    |____ views.py
                |____.env
                |____ manage.py
                |____ requirements.txt

        E no DIR fazemos:

            'DIRS': [os.path.join(BASE_DIR, 'templates')]

        BASE_DIR significa na raiz, o diretorio raiz.
        Fica:

            TEMPLATES = [
                {
                    'BACKEND': 'django.template.backends.django.DjangoTemplates',
                    'DIRS': [os.path.join(BASE_DIR, 'templates')],
                    'APP_DIRS': True,
                    'OPTIONS': {
                        'context_processors': [
                            'django.template.context_processors.debug',
                            'django.template.context_processors.request',
                            'django.contrib.auth.context_processors.auth',
                            'django.contrib.messages.context_processors.messages',
                        ],
                    },
                },
            ]

        Criando um index.html dentro de templates, com o conteudo:

            <!DOCTYPE html>
            <html>
            <head>
                <meta charset="utf-8">
                <meta name="viewport" content="width=device-width, initial-scale=1">
            </head>
            <body>
                <h1>Alura Space</h1>Bem vindo ao Espaço!
            </body>
            </html>


        Agora falamos para a galeria/views renderizar esta pagina.

        Assim, removemos o import de HttpResponse, pois usaremos o proprio render. o retorno vai ser o render, o primeiro parametro sempre vai ser a 'request', e depois o html.

        galeria/views.py:

            from django.shortcuts import render

            def index(request):
                return render(request, 'index.html')

        Assim, todos os nossos codigos HTML ficarao dentro da pasta templates!


Aula 11

    Carregando o template

        Para organizar melhor os templates de galeria, vamos criar um diretorio chamado galeria dentro de templates.
        e colocamos o index.html dentro da nova pasta:


                DJango
                |___templates
                    |____ galeria
                         |____ index.html
                |___venv
                    |____ bin (dir)
                    |____ lib (dir)
                    |____ pyvenv.cfg
                    |____ .gitignore
                |____ setup
                    |____ __init__.py
                    |____ aspi.py
                    |____ settings.py
                    |____ urls.py
                    |____ wsgi.py
                |____galeria
                    |____ migrations
                        |____ __init__.py
                    |____ __init__.py
                    |____ admin.py
                    |____ apps.py
                    |____ models.py
                    |____ tests.py
                    |____ views.py
                |____.env
                |____ manage.py
                |____ requirements.txt


        e no arquivo garieria/views.py
        alterar o caminho:

            from django.shortcuts import render

            def index(request):
                return render(request, 'galeria/index.html')

        E vamos carregar do ZIP alura_space-projeto_front o index.html, copiar e colar o conteudo para o index.html do nosso template.

        Esta tudo quebrado pois ainda faltam os CSS.

Aula 12

    Arquivos Estaticos (CSS e JS)

        Vamos criar uma variavel chamada STATICFILES_DIR dentro do setup/settings.py, para mostrar o caminho dos arquivos staticos, pode criar abaixo da variavel STATIC_URL.

            # Diretorio dos arquivos estaticos (CSS e JS)
            STATICFILES_DIR = [
                os.path.join(BASE_DIR, 'setup/static')
            ]

        Criamos uma pasta chamada static dentro de setup.

                DJango
                |___templates
                    |____ galeria
                         |____ index.html
                |___venv
                    |____ bin (dir)
                    |____ lib (dir)
                    |____ pyvenv.cfg
                    |____ .gitignore
                |____ setup
                    |____ static
                    |____ __init__.py
                    |____ aspi.py
                    |____ settings.py
                    |____ urls.py
                    |____ wsgi.py
                |____galeria
                    |____ migrations
                        |____ __init__.py
                    |____ __init__.py
                    |____ admin.py
                    |____ apps.py
                    |____ models.py
                    |____ tests.py
                    |____ views.py
                |____.env
                |____ manage.py
                |____ requirements.txt

        E criar outra variavel que vai mostrar o caminho absoluto para que o diretorio conseguir pegar esses arquivos estaticos (RECEITA DE BOLO). Serve para que o DJANGO processe os arquivos do static de depois jogue em algum lugar, para armazenar, para isso usamos o STATIC_ROOT.

            STATIC_ROOT = os.path.join(BASE_DIR, 'static')

        o DJANGO vai criar uma pasta chamada static, na raiz do projeto, para armazenar esses arquivos.

        Agora copiamos do ZIP de front, a pasta style para dentro do setup/static
                DJango
                |___templates
                    |____ galeria
                         |____ index.html
                |___venv
                    |____ bin (dir)
                    |____ lib (dir)
                    |____ pyvenv.cfg
                    |____ .gitignore
                |____ setup
                    |____ static
                        |____ style
                    |____ __init__.py
                    |____ aspi.py
                    |____ settings.py
                    |____ urls.py
                    |____ wsgi.py
                |____galeria
                    |____ migrations
                        |____ __init__.py
                    |____ __init__.py
                    |____ admin.py
                    |____ apps.py
                    |____ models.py
                    |____ tests.py
                    |____ views.py
                |____.env
                |____ manage.py
                |____ requirements.txt
        

        Vamos rodar o comando no terminal para que o DJANGO manipule todos os arquivos estaticos da aplicacao, visualiza-los. Vai pegar todos os arquivos estaticos, de alguma forma endereçar para que o DJANGO entenda onde estao as pastas e seus arquivos. E no deploy conseguirmos acessar todos os arquivos.


            python manage.py collectstatic


        Assim, ele cria na raiz do DJANGO um diretorio static com os stytles dentro:

                DJango
                |___templates
                    |____ galeria
                         |____ index.html
               |____ static
                    |____ admin
                    |____ style
                        |____ style.css
                |___venv
                    |____ bin (dir)
                    |____ lib (dir)
                    |____ pyvenv.cfg
                    |____ .gitignore
                |____ setup
                    |____ static
                        |____ style
                             |____ style.css
                    |____ __init__.py
                    |____ aspi.py
                    |____ settings.py
                    |____ urls.py
                    |____ wsgi.py
                |____galeria
                    |____ migrations
                        |____ __init__.py
                    |____ __init__.py
                    |____ admin.py
                    |____ apps.py
                    |____ models.py
                    |____ tests.py
                    |____ views.py
                |____.env
                |____ manage.py
                |____ requirements.txt  

        Na primeira linha do index.html, fazer uma variavel indicando que este arquivo vai usar arquivos estaticos.

            {% load static %}

        E no href do css, criar variavel para mostrar que o caminho esta dentro de static. e como colocamos codigo python junto ao html, isso se chama EMBEDADO!

             <link rel="stylesheet" href="{% static '/styles/style.css' %}">

        E com isso, o CSS é carregado a pagina.

Aula 13

    Carregando as imagens

        Da mesma forma que foi no css, vamos colocar as variaveis paras as imagens.

            <img src="{% static '/assets/logo/Logo(2).png' %}" alt="Logo da Alura Space" />

        Uma a uma.
        E colocamos dentro de setup/static a pasta assets.

        Depois disso executamos novamente o comando para criar indices de static:

            python manage.py collectstatic


Aula 14

    Outras páginas

        Vamos colocar o arquivo do zip chamado imagem.html dentro de templates/galeria

        Depois disso vamos adicionar o metodo dentro de galeria/views.py

            def imagem(request):
                return render(request, 'galeria/imagem.html')

        Depois add a url em galeria/urls.py

            from django.urls import path
            from galeria.views import index, imagem

            urlpatterns = [
                path('', index),
                path('imagem.html', imagem)
            ]

        Agora, as variaveis dentro do html para renderizar o css e imagens

            {% load static %}

            e

            <img src="{% static '/assets/ícones/1x/instagram.png' %}" alt="ícone instagram">

Aula 15

    URL name

        Esta dando erro ao clicar na imagem, pois esta mandao a gente para imagem.html, no nosso caso funicona pois em urls.py coloquei o path para 'imagem.html" para imagem. Ele tinha colocado 
        path('imagem/', imagem), apenas para testar.

        E como forma de boa pratica, vamos colocar codigo Django no index.html para a url:

            <a href="{% url 'imagem' %}">

        E dentro de /DJango/galeria/urls.py
        Add o name:

            from django.urls import path
            from galeria.views import index, imagem

            urlpatterns = [
                path('', index),
                path('imagem/', imagem, name="imagem")
            ]

        O mesmo faremos para o index.html, o botao HOME da erro pois nao direcionamos ainda. Criamos um name para o index:

            from django.urls import path
            from galeria.views import index, imagem

            urlpatterns = [
                path('', index, name="index"),
                path('imagem/', imagem, name="imagem")
            ]

        E no imagem.html onde tive o HOME: <a href="index.html"> COLOCAREMOS:

            <a href="{% url 'index'%}">


Aula 16

    Base E DRY

        Boas práticas:

            DRY - Não seja repetitivo (Don't repeat yourself)

                Cada parte do nosso codigo nao pode ter em outro lugar, duplicado.

                Se observarmos os arquivos index.html e imagem.html, os comecos deles são iguais, {% load static %}, <html> <head> e etc.

            Dentro de /templates/galeria criaremos um arquivo chamado base.html

            Vamos manter a estrutura html padrao dos arquivos.

                    {% load static %}
                    <!DOCTYPE html>
                    <html lang="pt-br">

                    <head>
                        <meta charset="UTF-8">
                        <meta http-equiv="X-UA-Compatible" content="IE=edge">
                        <meta name="viewport" content="width=device-width, initial-scale=1.0">
                        <title>Alura Space</title>
                        <link rel="preconnect" href="https://fonts.googleapis.com">
                        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
                        <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet">
                        <link rel="stylesheet" href="{% static 'styles/style.css' %}">

                    </head>

                    <body>
                    </body>

                    </html>

        E arrancamos estes conteudos do index.html e imagem.html.

        E colocamos o seguinte conteudo no topo nos dois para puxar o base.html para eles, e mantermos os arquivos como static:

            {% extends 'galeria/base.html' %}
            {% load static %}

        E para passar o conteudo dos dois arquivos para o base.html, criamos uma variavel dentro do body:

            <body>
                {% block content %}{% endblock %}
            </body>

        e no index e imagem, para identificar o que é block, vamos adicionar o começo e fechamento:

            {% extends 'galeria/base.html' %}
            {% load static %}
            {% block content %}
                TODO O CONTEUDO
            {% endblock %}

Aula 17

    Partials

        Tirando as duplicações de menu e footer de imagem.html e index.html.

        quando temos funcionalidades e menu de navegacao, nao atribuimos ao base.html, e sim ao partial (pedaços, parciais), que sera uma pasta.

        criaremos o diretorio partials em templates/galeria.

        Criaremos o arquivo _footer.html em partials, por convenção fica com underline na frente.

        conteudo do _footer.html:

                {% load static %}
                <footer class="rodape">
                    <div class="rodape__icones">
                        <a href="https://twitter.com/AluraOnline" target=”_blank” >
                            <img src="{% static '/assets/ícones/1x/twitter.png' %}" alt="ícone twitter">
                        </a>
                        <a href="https://www.instagram.com/aluraonline/" target=”_blank” >
                            <img src="{% static '/assets/ícones/1x/instagram.png' %}" alt="ícone instagram">
                        </a>
                    </div>
                    <p class="rodape__texto">Desenvolvido por Alura</p>
                </footer>

        Tiramos este conteudo de index e imagem.

        Como eu quero que o footer e o menu fiquem em todos os arquivos da galeria, vamos adicionar no base.html

            <body>
                {% block content %}{% endblock %}
                {% include 'galeria/partials/_footer.html' %}
            </body>

        E isso é maravilhoso pois se tivermos que adicionar o ORKUT no footer, é so mudarmos em um local e ele muda para todos.

        Faremos o mesmo para o menu:

            /templates/galeria/partials/_menu.html

                {% load static %}
                <div class="pagina-inicial">
                    <header class="cabecalho">
                        <img src="{% static '/assets/logo/Logo(2).png' %}" alt="Logo da Alura Space" />
                        <div class="cabecalho__busca">
                            <div class="busca__fundo">
                                <input class="busca__input" type="text" placeholder="O que você procura?">
                                <img class="busca__icone" src="{% static '/assets/ícones/1x/search.png' %}" alt="ícone de search">
                            </div>
                        </div>
                    </header>
                    <main class="principal">
                        <section class="menu-lateral">
                            <nav class="menu-lateral__navegacao">
                                <a href="{% url 'index' %}"><img src="{% static '/assets/ícones/1x/Home - ativo.png' %}"> Home</a>
                                <a href="#"><img src="{% static '/assets/ícones/1x/Mais vistas - inativo.png' %}"> Mais vistas</a>
                                <a href="#"><img src="{% static '/assets/ícones/1x/Novas - inativo.png' %}"> Novas</a>
                                <a href="#"><img src="{% static '/assets/ícones/1x/Surpreenda-me - inativo.png' %}"> Surpreenda-me</a>
                            </nav>
                        </section>

            perceba que o html esta quebrado

            /templates/galeria/base.html

                <body>
                    {% include 'galeria/partials/_menu.html' %}
                    {% block content %}{% endblock %}
                    {% include 'galeria/partials/_footer.html' %}
                </body>

            /templates/galeria/imagem.html

                {% extends 'galeria/base.html' %}
                {% load static %}
                {% block content %}

                            <section class="conteudo">
                                <section class="imagem">
                                    <div class="imagem__conteudo">
                                        <img class="imagem__imagem" src="{% static '/assets/imagens/galeria/carina-nebula.png' %}">
                                        <div class="imagem__info">
                                            <div class="imagem__texto">
                                                <p class="imagem__titulo">“Penhascos Cósmicos” na Nebulosa Carina</p>
                                                <p class="imagem__descricao">12 de julho de 2022</p>
                                                <p class="imagem__texto">O que se parece muito com montanhas escarpadas em uma noite enluarada é na verdade a borda de uma região jovem e próxima de formação de estrelas NGC 3324 na Nebulosa Carina. Capturada em luz infravermelha pela Near-Infrared Camera ( NIRCam ) no Telescópio Espacial James Webb da NASA, esta imagem revela áreas anteriormente obscurecidas do nascimento de estrelas.</p>
                                            </div>
                                        </div>
                                    </div>
                                </section>
                            </section>
                        </main>
                    </div>
                {% endblock%}

        html quebrado!
        e arrancamos o mesmo para o index.html

Obsevação, ele subiu todo o setup/static para o github.

    https://github.com/alura-cursos/alura_space

Fim de Curso!

Parabéns!!!
