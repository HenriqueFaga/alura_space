Backend (Persistencia de dados) e ADM com DJANGO

1 - Preparando Ambiente

	Vamos puxar o projeto do alura space do github para a maquina local. Em uma pasta que queira:

		git clone https://github.com/HenriqueFaga/alura_space.git

	E criar o virtualenv, com nome de .venv, o que no nosso caso que ja está só venv (no W
	indows):

		python -m virtualenv .venv

	ativando o venv:

		no windows:

			.venv/Script/activate

		no linux:

			source .venv/bin/activate

	instalar os requirements.txt:

		pip install -r requirements.txt

	iniciando o projeto:

		python manage.py runserver

	Rodando em:

		http://127.0.0.1:8000/



2 - Nomes dinâmicos

		Removendo repetição de cards dentro do templates/galeria/index.html. Deixando apenas um desse:

	            <li class="card">
                    <a href="{% url 'imagem' %}">
                        <img class="card__imagem" src="{% static '/assets/imagens/galeria/carina-nebula.png' %}" alt="foto">
                    </a>
                    <span class="card__tag">Estrelas</span>
                    <div class="card__info">
                        <p class="card__titulo">Nome da foto</p>
                        <div class="card__texto">
                            <p class="card__descricao">Fonte/fotógrafo/satélite</p>
                            <span>
                                <img src="{% static '/assets/ícones/1x/favorite_outline.png' %}" alt="ícone de coração">
                            </span>
                        </div>
                    </div>
                </li>

        Vamos na /galeria/views.py para criar dados (estrutura de dados ) para enviar ao index.html.

	        from django.shortcuts import render

			def index(request):

		        dados = {
		        	1: {'nome': 'Nebulosa de Carina',
		        		'legenda': 'webbtelescope.org / NASA/ James Webb'},
		        	2: {'nome': 'Galáxia NGC 1079',
		        		'legenda': 'nasa.org / NASA / Hubble'}
		        }

			    return render(request, 'galeria/index.html', {'cards': dados})

			def imagem(request):
			    return render(request, 'galeria/imagem.html')

		No index.html, vamos criar uma estrutura de repetição para dados, assim puxar as informações do dict e colocar para cada lista de cards.

		exemplo de loop:

			{% for id, value in dados.items %}
				{{ id }}
			{% endfor %}
		IMPORTANTE! No python, o dados.items deve estar com parenteses no final dados.items()
			No caso do DJango não! Testei tanto no Python 2.7 como no Python 3.8.

		no index.html:

            {% for foto_id, info in cards.items %}
            <li class="card">
                <a href="{% url 'imagem' %}">
                    <img class="card__imagem" src="{% static '/assets/imagens/galeria/carina-nebula.png' %}" alt="foto">
                </a>
                <span class="card__tag">Estrelas</span>
                <div class="card__info">
                    <p class="card__titulo">{{ info.nome }}</p>
                    <div class="card__texto">
                        <p class="card__descricao">{{ info.legenda }}</p>
                        <span>
                            <img src="{% static '/assets/ícones/1x/favorite_outline.png' %}" alt="ícone de coração">
                        </span>
                    </div>
                </div>
            </li>
            {% endfor %}


3 - Banco de Dados:

	Dentro de galeria temos um script chamado models.py

	Na model vamos criar estruturas em classes para que o DJango interprete como Tabela do Banco. Ele traduz uma classe para uma tabela do banco de dados.

	Object-Relational-Mapper (ORM): Fará a tradução das classes (python puro) para banco de dados.

	No galeria/models.py

		from django.db import models

		class Fotografia(models.Model):
		    # Colunas:

		    # CharField -> String;
		    # max_length maximo de char.
		    # null=False nao pode ser nulo.
		    # blank=False nao pode ser string vazia!
		    nome = models.CharField(max_length=100, null=False, blank=False)
		    legenda = models.CharField(max_length=150, null=False, blank=False)
		    # TextField -> campo de texto
		    descriacao = models.TextField(null=False, blank=False)
		    foto = models.CharField(max_length=150, null=False, blank=False)

		    def __str__(self):
		        # Boa pratica, devolve o nome de cada um dos itens.
		        return f"Fotografia [nome={self.nome}]"

	Migration: 
	Usamos o comando makemigrations para mostrar para o Django que há uma nova tabela do banco de dados que desejamos traduzir para, definitivamente, uma tabela no banco de dados.

		python manage.py makemigrations

	Assim, usando o comando acima, ele cria um arquivo:

		Migrations for 'galeria':
		  galeria/migrations/0001_initial.py
		    - Create model Fotografia

	Nesse documento: galeria/migrations/0001_initial.py
	Temos um relatorio do que quero fazer:

		# Generated by Django 4.2.13 on 2024-06-30 23:27

		from django.db import migrations, models


		class Migration(migrations.Migration):

		    initial = True

		    dependencies = [
		    ]

		    operations = [
		        migrations.CreateModel(
		            name='Fotografia',
		            fields=[
		                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
		                ('nome', models.CharField(max_length=100)),
		                ('legenda', models.CharField(max_length=150)),
		                ('descriacao', models.TextField()),
		                ('foto', models.CharField(max_length=150)),
		            ],
		        ),
		    ]

	Perceba que ele criou automaticamente um ID, como prymary_key inteiro.

	E assim para que de fato ele crie a tabela:

		python manage.py migrate

	Assim, criamos o banco de dados, usando um já existente dentro do DJango chamado SQLITE.

	E criou o bando de dados no arquivo na raiz:

		db.sqlite3

	Abrindo ele conseguimos ver que tem umas tabelas que foram criados automaticamente e um chamada galeria_fotografia.


Observacoes:

	Cada linguagem (ou mesmo framework) que suporta orientação a objetos possui um ORM de utilização mais comum:

		Python e Flask: SQLAlchemy;
		Python e Django: Django ORM;
		Java: Hibernate;
		C#: Dapper ORM;
		PHP: Doctrine;
		.NET framework : Microsoft Entity Framework.

	Vantagens da utilização de um ORM:
		Possibilita, para quem programa, construir bancos de dados utilizando sua linguagem de programação de maior fluência, sem ter que se aprofundar nas complexidades do código SQL;
		Torna a aplicação independente do RDBMS utilizado. Isso facilita uma eventual migração de banco de dados, bem como a escrita de queries genéricas que se enquadram nos mais diversos RDBMS (MySQL, PostgreSQL, Microsoft SQL Server, etc);
		A conexão entre a aplicação e o banco de dados se torna robusta, segura e menos sujeita a erros de código, uma vez que poucas intervenções de código são necessárias;
		Alguns ORM como o SQLAlchemy possuem um toolkit completo de ferramentas extras que otimizam a interação com o banco de dados.
	Desvantagens da utilização de um ORM:
		A integração de ORMs com sistemas legados pode ser problemática;
		Pode criar a ilusão, para desenvolvedores iniciantes, que não é necessária uma compreensão básica de linguagem SQL para se tornar um profissional completo de desenvolvimento de aplicações web.

4 - Criando Dados

	Vamos no terminal e colocamos o comando:

		python manage.py shell

	Assim ele abre uma shell interativa do proprio DJANGO.

	No python shell do django, vamos codar:

		>>> from galeria.models import Fotografia
		>>> foto = Fotografia(nome="Nebulosa de Carina", legenda='webbtelescope.org / NASA/ James Webb', foto="carina-nebula.png")
		>>> foto.save()

	Desta forma ele cria a linha no banco, repare que ele coloca os valores da classe nos parenteses direto!

	O que tambem da pra fazer desta forma:

		>>> from galeria.models import Fotografia
		>>> foto = Fotografia()
		>>> foto.nome = 'Nasa'
		>>> foto
		<Fotografia: Fotografia [nome=Nasa]>

	Vendo todos os objetos de Fotografia:

		>>> Fotografia.objects.all()
		<QuerySet [<Fotografia: Fotografia [nome=Nebulosa de Carina]>]>

	o "Fotografia: Fotografia [nome=Nebulosa de Carina]" aparece por conta da boa prática que fizemos com def __str__

	Outra boa pratica interessante, dentro de setup/settings.py, vamos em INSTALLED_APPS e ao inves de colocar só 'galeria', vamos trocar por 'galeria.apps.GaleriaConfig'.

	Chamando a galeria dessa forma, ele não vai puxar somente o aplicativo, e sim todos os arquivos com as configurações. Se realizarmos alguma alteração na aplicação, ele atualiza e puxa essa modificação.

	GaleriaConfig é a classe dentro de galeria/app.py

		INSTALLED_APPS = [
		    'django.contrib.admin',
		    'django.contrib.auth',
		    'django.contrib.contenttypes',
		    'django.contrib.sessions',
		    'django.contrib.messages',
		    'django.contrib.staticfiles',
		    'galeria.apps.GaleriaConfig',
		]

	esse app.py foi criado pelo Django no momento da criacao de galeria.

	Django ORM para transformar as classes models em tabelas no banco de dados.


5 - Acessando o banco

		Removendo o dict dados estatico dentro de
		/galeria/views.py para puxarmos direto do banco.

		Puxando do banco, precisamos importar a classe fotografia e instancia dentro do index, para puxar todos os objetos dela:

			from django.shortcuts import render
			from galeria.models import Fotografia

			def index(request):
			    # request, template_name, context=None, content_type=None, status=None, using=None
			    fotografias = Fotografia.objects.all()
			    return render(request, 'galeria/index.html', context={'cards': fotografias})

			def imagem(request):
			    return render(request, 'galeria/imagem.html')


		Em templates/galeria/index.html vamos mudar o for, e criar uma condicao para que se tiver cards mostre (e nao mostrar erro se nao tiver nada na tabela), ficando:

			{% if cards %}
				{% for fotografia in cards%}
				{% endfor %}
			{% else %}
			{% endif%}

		Ele colocou um else vazio, mas nao vejo necessidade.
		E cada variavel, ao inves de info.nome vai ser fotografia.nome .

		Ficando:

            {% if cards %}
            	{% for fotografia in cards %}
                    <li class="card">
                        <a href="{% url 'imagem' %}">
                            <img class="card__imagem" src="{% static '/assets/imagens/galeria/' %}{{ fotografia.foto }}" alt="foto">
                        </a>
                        <span class="card__tag">Estrelas</span>
                        <div class="card__info">
                            <p class="card__titulo">{{ fotografia.nome }}</p>
                            <div class="card__texto">
                                <p class="card__descricao">{{ fotografia.legenda }}</p>
                                <span>
                                    <img src="{% static '/assets/ícones/1x/favorite_outline.png' %}" alt="ícone de coração">
                                </span>
                            </div>
                        </div>
                    </li>
                {% endfor %}
            {% else %}
            {% endif %}

        E transformou o path da imagem tambem dinamico. {% static '/assets/imagens/galeria/' %}{{ fotografia.foto }}


6 - Passando uma referência

		Adicionando mais uma foto no banco:

			python manage.py shell

			>>> from galeria.models import Fotografia
			>>> foto = Fotografia(nome="Galaxia NGC 1079", legenda="naga.org / Nasa / Hubble", foto='hubble_ngc1079.jpg')

		Antes de adicionarmos a foto, vamos colocar a imagem da foto nova que baixamos em:
			https://github.com/alura-cursos/2711-projeto-django-2/blob/aula_2/setup/static/assets/imagens/galeria/hubble_ngc1079.jpg

		Vamos colar esta foto em:

			DJango/setup/static/assets/imagens/galeria/hubble_ngc1079.jpg

		Há outra pasta chamada "static" no projeto, mas a que precisamos arrastar a imagem está dentro da pasta "setup". A pasta "static" que está fora de "setup" foi gerada quando rodamos 'collect static' no curso anterior.

		Ao executarmos o comando 'collect static' o Django diferencia dois tipos de diretórios: para aplicações em desenvolvimento e outro para o statics que referenciam a aplicação que está em produção. Nesse curso, usaremos o diretório para aplicações em desenvolvimento (dentro de "setup").

		Então, só podemos adicionar, apagar e etc dentro de setup/static

		Agora que temos a imagem, podemos inserir a fotografia pelo shell!

			>>> foto.save()

		Deixando dinamico a imagem em imagem.html, então vamos passar um parametro no index.html para que ao clicar e redirecionar para imagem.html tenha o ID da foto.

			Index.html, Parametro fotografia.id:

				<a href="{% url 'imagem' fotografia.id %}">
					<img class="card__imagem" src="{% static '/assets/imagens/galeria/' %}{{ fotografia.foto }}" alt="foto">
                </a>

            Em galeria/urls.py, parametro foto_id sendo um inteiro:

            	from django.urls import path
				from galeria.views import index, imagem

				urlpatterns = [
				    path('', index, name="index"),
				    path('imagem/<int:foto_id>', imagem, name="imagem")
				]

			Na galeria/views.py, no metodo imagem colocaremos o parametro foto_id:

				def imagem(request, foto_id):
    				return render(request, 'galeria/imagem.html')

    		Continuando em galeria/views.py, vamos puxar do banco a foto com o inteiro ID, que por sinal é um mero número inteiro, ele nao sabe o que fazer com isso, nem tem o mesmo nome em banco.

    		Vamos instancia a fotografia usando o metodo get_object_or_404, que se nao encontrar a imagem da um erro de 404, passando a Model Fotografia e a primary key. Importamos do shortcuts o get_object_or_404. E no render criamos um dict com a info de fotografia:

				from django.shortcuts import render, get_object_or_404
				from galeria.models import Fotografia

				def index(request):
				    # request, template_name, context=None, content_type=None, status=None, using=None
				    fotografias = Fotografia.objects.all()
				    return render(request, 'galeria/index.html', context={'cards': fotografias})

				def imagem(request, foto_id):
				    fotografia = get_object_or_404(Fotografia, pk=foto_id)
				    return render(request, 'galeria/imagem.html', {'fotografia': fotografia})

			Em imagem.html:

				{% extends 'galeria/base.html' %}
				{% load static %}
				{% block content %}

				            <section class="conteudo">
				                <section class="imagem">
				                    <div class="imagem__conteudo">
				                        <img class="imagem__imagem" src="{% static '/assets/imagens/galeria/' %}{{ fotografia.foto }}">
				                        <div class="imagem__info">
				                            <div class="imagem__texto">
				                                <p class="imagem__titulo">{{ fotografia.nome }}</p>
				                                <p class="imagem__descricao">{{ fotografia.legenda }}</p>
				                                <p class="imagem__texto"></p>
				                            </div>
				                        </div>
				                    </div>
				                </section>
				            </section>
				        </main>
				    </div>
				{% endblock%}

			Perceba que nao faz "for" para interar cada fotografia, neste caso só temos dentro de dados uma chave como "fotografia".


7 - Django Admin 
		
		Forma mais fácil para inserir dados no banco de dados.

		Documentação:

			https://docs.djangoproject.com/en/4.1/ref/contrib/admin/

		O DJango Admin já está ativo na aplicação:

			http://127.0.0.1:8000/admin

		Mas o login não é admin/admin

		Vamos criar o famoso SUPER USUARIO.
		No terminal:

			python manage.py createsuperuser

		Vai pedir para criar o usuario, email(nao necessário, pode deixar em branco) e senha.

		Nesta aplicação esta henrique/admin

		Agora podemos logar!

		Por enquanto é só um ADMIN vazio, sem as tabelas, apenas USUARIOS E GRUPOS.

8 - CRUD no Admin

		Vamos adicionar o banco de dados dentro do Django Admin. Para isso, vamos ao arquivo "admin.py" dentro do pacote "galeria".

			DJango/galeria/admin.py
			
				from django.contrib import admin
				from galeria.models import Fotografia

				admin.site.register(Fotografia)

		Com isso, se dervmos reload no site, já aparece a GALERIA / FOTOGRAFIA no ADMIN!

		Clicando nela, aparece as linhas do banco:

			FOTOGRAFIA
			Fotografia [nome=Galaxia NGC 1079]
			Fotografia [nome=Nebulosa de Carina]

		E clicando em "ADICIONAR FOTOGRAFIA" podemos criar mais uma linha em banco!
		E Na "Ação" > "Remover fotografias delecionados" podemos remover a linha!!!

		Personalizar o Admin:

			Essa parte das linhas ta muito feia:

				Fotografia [nome=Nebulosa de Carina]

			Vamos mudar isso.
			Em DJango/galeria/admin.py criamos uma classe chamada ListandoFotografias herdando admin.ModelAdmin. um parametro chamado list_display com as colunas que quero mostrar. Depois coloco como parametro no register:

				from django.contrib import admin
				from galeria.models import Fotografia

				class ListandoFotografias(admin.ModelAdmin):
				    list_display = ("id", "nome", "legenda")

				admin.site.register(Fotografia, ListandoFotografias)

			Assim aparece mais bonito:

				ID  NOME    		    LEGENDA
				2	Galaxia NGC 1079	naga.org / Nasa / Hubble
				1	Nebulosa de Carina	webbtelescope.org / NASA/ James Webb

			Colocando o link da pagina da fotografia para que quando eu clique no nome ou no id dela vá para sua pagina de edição da linha:

				from django.contrib import admin
				from galeria.models import Fotografia

				class ListandoFotografias(admin.ModelAdmin):
				    list_display = ("id", "nome", "legenda")
				    list_display_links = ("id", "nome")

				admin.site.register(Fotografia, ListandoFotografias)

			E pronto! Adicionamos só o parametro padrão list_display_links que o django identifica para colocar os links em ID e Nome.

			Se formos pelo VSCODE e tiver a extensão para ver SQLITE, conseguiremos ver as mudanças salvas ou adicionadas em fotografias. Então foi manipulado no nosso banco de dados!

			Adicionando um campo de busca, para que se tivermos um monte de fotos fique mais facil para encontrarmos.

			Continuando pelo DJango/galeria/admin.py, add mais um parametro chamado search_fields para buscar por nome:

				from django.contrib import admin
				from galeria.models import Fotografia

				class ListandoFotografias(admin.ModelAdmin):
				    list_display = ("id", "nome", "legenda")
				    list_display_links = ("id", "nome")
				    search_fields = ("nome",)

				admin.site.register(Fotografia, ListandoFotografias)

			Vendo que precisa ter uma virgula no final da tupla, pois se não vira string sozinha, apenas uma string, e precisa ser tupla. Exemplo no python:

				>>> a = ("qwe")
				>>> a
				'qwe'
				>>> a = ("123", )
				>>> a
				('123',)

			 Diferente da lista, que mesmo tendo um elemento fica como lista! Tupla é bugado.

			 	>>> b = [1]
				>>> b
				[1]

			E com o search já aparece o campo para pesquisar por nome.

			Se colocarmos tambem por ID, ele busca por ID!

				search_fields = ("nome", "id")

			O que é muito bom e rapido!

			O mesmo para leganda! E so colocando um trecho de pesquisa, ele encontra tudo relacionado, como se usasse por tras dos panos um ILIKE!

				search_fields = ("nome", "id", "legenda")


9 - Incluindo categoria
		
		Vamos incluir a coluna categoria dentro de Fotografia, para os botões de busque por tags no index do site.

		Dentro de DJango/galeria/models.py adicionamos uma variavel a mais para categoria:

			categoria = models.CharField(max_length=150, null=False, blank=False)

		Mas, categoria não pode ser qualquer uma, tem que ser pré definida só algumas. Para isso vamos criar uma lista com os tipos de categorias

			OPCOES_CATEGORIA = [
				("NEBULOSA", "Nebulosa"),
				("ESTRELA", "Estrela"),
				("GALÁXIA", "Galáxia"),
				("PLANETA", "Planeta")
			]

		E deve ser neste formato de tupla para o DJANGO entender, pois foi programado desta forma.

		Em categoria add o parametro choices com as OPCOES_CATEGORIA. Podendo remover NULL E BLANK pois nunca serão, COLOCANDO default string vazio:

			categoria = models.CharField(max_length=150, choices=OPCOES_CATEGORIA, default='')

		Ficando:

			DJango/galeria/models.py

				from django.db import models

				class Fotografia(models.Model):
				    # Colunas:

				    OPCOES_CATEGORIA = [
				        ("NEBULOSA", "Nebulosa"),
				        ("ESTRELA", "Estrela"),
				        ("GALÁXIA", "Galáxia"),
				        ("PLANETA", "Planeta")
				    ]

				    # CharField -> String;
				    # max_length maximo de char.
				    # null=False nao pode ser nulo.
				    # blank=False nao pode ser string vazia!
				    nome = models.CharField(max_length=100, null=False, blank=False)
				    legenda = models.CharField(max_length=150, null=False, blank=False)
				    # TextField -> campo de texto
				    descriacao = models.TextField(null=False, blank=False)
				    foto = models.CharField(max_length=150, null=False, blank=False)
				    categoria = models.CharField(max_length=150, choices=OPCOES_CATEGORIA, default='')

				    def __str__(self):
				        # Boa pratica, devolve o nome de cada um dos itens.
				        return f"Fotografia [nome={self.nome}]"

		E como mexemos no banco, ele NÃO vai automatico! Precisamos vazer uma migration!

			python manage.py makemigrations

		Retorno:

			Migrations for 'galeria':
			  galeria/migrations/0002_fotografia_categoria.py
			    - Add field categoria to fotografia

		Dentro de galeria/migrations/0002_fotografia_categoria.py aparece a categoria nova e suas choices!

		E depois mais um comando, para efetivamente ir para banco:

			python manage.py migrate

		Retorno:

			Operations to perform:
			  Apply all migrations: admin, auth, contenttypes, galeria, sessions
			Running migrations:
			  Applying galeria.0002_fotografia_categoria... OK

		Rode o server novamente:

			python3 manage.py runserver

		Se rodar o runserver antes do migrate ele da pau pra iniciar o banco.

		Entrando no ADMIN e indo numa fotografia, estará lá um SELECT BOX para escolher a categoria e está como padrão NEBULOSA.

		Add categoria no list_display do galeria/admin.py vemos que
		as antigas não ficam com categoria nova tem que add:

			ID  NOME                LEGENDA                             CATEGORIA
			2	Galaxia NGC 1079	naga.org / Nasa / Hubble	            -
			1	Nebulosa de Carina	webbtelescope.org / NASA/ James Webb	-


10 - Personalizando o admin

		1 - Colocando Filtro por categoria, sendo exemplo de filtro por ordem alfabetica, menor preço e etc.

		Em DJango/galeria/admin.py, vamos colocar mais uma variavel chamada
		list_filter e a tupla com com a categoria:

			list_filter = ("categoria", )

		No canto direito em http://127.0.0.1:8000/admin/galeria/fotografia/ aparece
		um filtro para selecionar por tipo de categoria.

		Ficando:

			from django.contrib import admin
			from galeria.models import Fotografia

			class ListandoFotografias(admin.ModelAdmin):
			    list_display = ("id", "nome", "legenda", "categoria")
			    list_display_links = ("id", "nome")
			    search_fields = ("nome", "id", "legenda")

			admin.site.register(Fotografia, ListandoFotografias)

		2 - Colocando paginação para fotografias.
		Suponha que temos 50 itens no nosso Django Admin. Todos eles ficarão comprimidos nessa única página? Não! Quero que haja uma quebra a partir de pelo menos 10 itens por página.
		Para isso, vamos retornar ao código, colocar o atributo list_per_page e definir 10 itens. Antes para teste vamos colocar 1 por pagina.

			list_per_page = 1

		E lá teremos duas paginas pois temos duas fotos.

			list_per_page = 10

		Na documentação mostra inumeras coisas que da pra personalizar mais o DJango!


11 - Funcionalidade de publicação

		Já avançamos com várias opções no nosso admin, mas ainda quero adicionar uma funcionalidade ao site. Nele, temos uma galeria de fotografias do espaço.

		Suponha que eu queira inserir uma fotografia e não tenho certeza se quero que ela apareça no index logo de cara, ou seja, quero ter a possibilidade de escolher se ela será ou não publicada na página principal.

		Inserimos o item no banco de dados da nossa aplicação, mas por enquanto, não queremos publicá-lo. Às vezes, ainda falta alguma informação que será buscada. Como pessoa usuária, seria interessante ter essa premissa.

		Faremos isso alterando o nosso model, adicionando um campo chamado publicada. Em frente, colocamos models.BooleanField e definimos o default como "False". Assim o padrão entra como False e só se quisermos publicar colocamos como True.

			DJango/galeria/models.py

				publicada = models.BooleanField(default=False)

		Para add em banco:
			python manage.py makemigrations
			python manage.py migrate


		Na view temos que criar a regra, trocando o all() para filter(publicada=True):

			DJango/galeria/views.py >> index

				

		Com isso, as fotografias saem do site, então precisamos colocar na edição de cada fotografica o publicada checked (True).

		Colocando para mostrar o campo publicada na tabela de fotografia no admin:

			DJango/galeria/admin.py

				list_display = ("id", "nome", "legenda", "categoria", "publicada")

		Assim ele mostra dois icones bonitinhos, um com checked verde (True) e outro com x vermelho (False).

		Para nao precisarmos entrar na tela de edição da fotografia para pode alterar o publicada e já na tabela podemos dar o checked, podemos add uma nova variavel chamada list_editable com a tupla com "publicada":

			list_editable = ("publicada",)

		Assim podemos colocar o check ou tirar da publicada e clicar em "Salvar" para salvar!


12 - Incrementando o index
	
		Criando um campo Data na Fotografia para que assim que eu add uma nova fotografia, fique com a data de inserção. E default vai ser NOW, a data do instante da inserção, então devemos importar a biblioteca datetime

			DJango/galeria/models.py

				from datetime import datetime 

				data_fotografia = models.DateTimeField(default=datetime.now, blank=False)

		Para add em banco:
			python manage.py makemigrations
			python manage.py migrate

		Se formos no editar da foto em admin, tem o campo da data com a seleção de data e hora!

		Ordenando pelo mais recente no site:

			DJango/galeria/views.py >> index

				fotografias = Fotografia.objects.order_by("data_fotografia").filter(publicada=True)

		Assim já aparece pelo mais recente

		Se eu quiser inverter, do mais antigo para o mais recente, colocamos um menos na frente da data_fotografia dentro string:

				fotografias = Fotografia.objects.order_by("-data_fotografia").filter(publicada=True)

13 - Upload de Imagem

		Até agora, para subir uma imagem, teriamos que colocar ela dentro static e depois colocar o caminho (no caso o nome dela: hubble_ngc1079.jpg) da foto na mão dentro da coluna Foto da tabela fotografia.

		Queremos fazer isso de forma automatica dentro da tela de CRUD no ADMIN, realizando o upload!

		Em setup/settings.py vamos criar um diretorio exclusivo para arquivos de media

			setup/settings.py

				# Media

				MEDIA_ROOT = os.path.join(BASE_DIR, "media")
				MEDIA_URL = "/media/"

		Da mesma forma que criamos referências de STATIC_URL e STATIC_ROOT porque criamos um diretório específico só para os arquivos estáticos, faremos o mesmo para os arquivos de mídia, que correspondem às imagens subidas no site pelas pessoas usuárias.

		Para fazer isso, inseriremos o comentário # Media logo abaixo das variáveis globais STATIC_URL, STATICFILES_DIRS e STATIC_ROOT, para indicar que a seguir virão as questões de mídia.

		A primeira coisa que colocaremos a seguir é o MEDIA_ROOT = os.path.join(). Dentro dos parênteses, queremos que ele busque o caminho de um diretório que ficará dentro do nosso diretório base do projeto.

		Daremos a instrução BASE_DIR, "media" para que seja feita a busca por um diretório chamado "media" no diretório base. Usaremos o nome em inglês porque é o nome padrão usado para esse tipo de diretório.

		A próxima variável global que criaremos é a MEDIA_URL = "/media/". Essas são as duas referências que usaremos para o nosso diretório de mídia, mas isso não é suficiente.

		No urls.py do setup, colocamos uma concatenacao com urlpatterns, será uma soma de listas, com + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT), e importamos o settings e o static do django:

			setup/urls.py

				from django.contrib import admin
				from django.urls import path, include
				from django.conf import settings
				from django.conf.urls.static import static


				urlpatterns = [
				    path('admin/', admin.site.urls),
				    path('', include('galeria.urls')),
				] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

		Alterando a model de galeria para transformar o campo foto de charfield para ImageField, com parametro upload_to que vai dizer onde deve realizar o upload da imagem, criando um diretorio "fotos" em media. Para nao termos problemas com cadastro de imagens com mesmo nome e substituir a outra, vamos criar diretorios com ano mÊs e dia "/foto/ANO/MES/DIA/" da data que está sendo feito o upload. Seungo Parametro como blank=True, ou seja, podemos cadastrar uma imagem sem ter uma imagem, o que é estranho, mas pode acontecer, então nesse caso colocaremos uma imagem padrão.

			galeria/models.py:

				foto = models.ImageField(upload_to="foto/%Y/%m/%d/", blank=True)

		Modamos a model fazemos a migração:
			python manage.py makemigrations
			python manage.py migrate

		Agora no ADMIN, clicando para add nova fotografia temos o campo para fazer o upload!
		Fazendo o upload da imagem, ela fica em banco na coluna foto neste formato:

			foto/2024/08/02/teste.jpg

		E na raiz do projeto ele criou o diretorio media:

			media
			|__foto
				|__2024
					|__08
						|__02
							|__teste.jpg

14 - Imagem "not found"

		Fizemos o upload no media mas nao configuramos ainda para aparecer no site.
		As imagens antigas nao estao no media, estao no diretorio static!

		Vamos fazer uma boa pratica antes que se nao encontrou a imagem ele mostra uma foto padrão.

		Vamos baixar a imagem not-found.png e colar dentro de setup/static/assets/imagens/galeria

		No index.html em templates/galeria criamos uma estrutura condicional que quando nao tem aparece not-found, se tem aparece a imagem. Lembrando que quando mudamos de charfield para imagefield, ainda existe a string da antiga imagem, por exemplo hubble_ngc1079.jpg na coluna foto, isso significa que vai aparecer a string no editar da fotografia mas na hora que o django pega e transforma em imagemfield ele não acha a imagem, entao no IF, por mais que tenha a string em fotografia.foto, ele nao gerou a imagem, entao o IF funciona, ele nao valida se tem string neste caso, a string  hubble_ngc1079.jpg, valida a imagem. Por isso colocamos o atributo url em fotografia.foto.url!!!

			templates/galeria/index.html

                <a href="{% url 'imagem' fotografia.id %}">
                    {% if fotografia.foto == "" or fotografia.foto == null %}
                        <img class="card__imagem" src="{% static '/assets/imagens/galeria/not-found.png' %}" alt="foto">
                    {% else %}
                        <img class="card__imagem" src="{{ fotografia.foto.url }}" alt="foto">
                    {% endif %}
                </a>

        Agora funciona para a nova imagem no media, mas as antigas deram ruim. Vamos fazer upload das antigas no ADMIN para ficar tudo bonito!

        Se queremos subistituir uma que ja esta no media, tem o botao limpar, mas ele so server para apagar a string em banco e nao a imagem no media, ficando sem referencia a imagem em banco. Se fizermos upload da mesma imagem, com mesmo nome, ele coloca novamente sem apagar a anterior, colocando um texto aleatorio ao fim:

        	foto/2024/08/02/carina-nebula_pcFutuk.png

15 - Alterando template imagem

		Alterando para pegar no media em templates/galeria/imagem.html

	        {% if fotografia.foto == "" or fotografia.foto == null %}
	            <img class="card__imagem" src="{% static '/assets/imagens/galeria/not-found.png' %}" alt="foto">
	        {% else %}
	            <img class="card__imagem" src="{{ fotografia.foto.url }}" alt="foto">
	        {% endif %}

	    Pronto!

	    Se cadastrarmos uma foto sem imagem, ele aparece o not-found!!!

	    Ajustando a referencia que esta feia quando clicamos para ediar a foto em ADMIN:

	    		Início › Galeria › Fotografias › Fotografia [nome=Galaxia NGC 1079]

	   	Que foi bem util no terminal, mas agora não. Vamos colocar apenas o nome da FOTO:

	   		/galeria/models.py

	   			Antes:

	   				def __str__(self):
				        # Boa pratica, devolve o nome de cada um dos itens.
				        return f"Fotografia [nome={self.nome}]"

				Depois:


	   				def __str__(self):
				        # Boa pratica, devolve o nome de cada um dos itens.
				        return self.nome

		Pronto:

			Início › Galeria › Fotografias › Galaxia NGC 1079

Obs:

	Durante o desenvolvimento de uma aplicação Django, dividimos nossa aplicação em duas partes: nosso site e o admin do Django, onde criamos os conteúdos que serão exibidos no site. Porém, no Django é possível filtrar ou ordenar os objetos que queremos renderizar no site.

	É possível buscar todos os objetos, sem filtros e sem ordenação.

	É possível adicionar mais de um filtro.

	Podemos adicionar mais de um filtro, por exemplo: Fotografia.objects.order_by('-data_fotografia').filter(publicada=True).filter(categoria=nebulosa).